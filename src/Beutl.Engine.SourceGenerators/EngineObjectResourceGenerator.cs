using System.Collections.Immutable;
using System.Text;

using Beutl.Engine.SourceGenerators.Analysis;
using Beutl.Engine.SourceGenerators.Diagnostics;
using Beutl.Engine.SourceGenerators.Emit;
using Beutl.Engine.SourceGenerators.Models;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Beutl.Engine.SourceGenerators;

[Generator]
public sealed class EngineObjectResourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classDeclarations = context.SyntaxProvider.CreateSyntaxProvider(
                static (node, _) => node is ClassDeclarationSyntax { BaseList: not null },
                static (syntaxContext, cancellationToken) => ClassInfoExtractor.TryExtract(syntaxContext, cancellationToken))
            .Where(static info => info is not null)
            .Select(static (info, _) => info!.Value);

        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndClasses, static (productionContext, pair) =>
            Execute(productionContext, pair.Left, pair.Right));
    }

    private static void Execute(SourceProductionContext context, Compilation compilation, ImmutableArray<ClassInfo> classes)
    {
        if (classes.IsDefaultOrEmpty)
        {
            return;
        }

        var processed = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);

        foreach (ClassInfo info in classes)
        {
            if (!processed.Add(info.Symbol))
            {
                continue;
            }

            if (!info.IsPartial)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    DiagnosticDescriptors.MissingPartial,
                    info.Symbol.Locations.FirstOrDefault(),
                    info.Symbol.ToDisplayString()));
                continue;
            }

            string source = GenerateSource(info);
            string hintName = EmitHelpers.GetHintName(info.Symbol);
            context.AddSource(hintName, source);
        }
    }

    private static string GenerateSource(ClassInfo info)
    {
        INamedTypeSymbol symbol = info.Symbol;
        string? namespaceName = symbol.ContainingNamespace is { IsGlobalNamespace: false } ns
            ? ns.ToDisplayString()
            : null;

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("#pragma warning disable CS8631");
        sb.AppendLine();

        if (namespaceName is not null)
        {
            sb.AppendLine($"namespace {namespaceName};");
            sb.AppendLine();
        }

        string accessibility = EmitHelpers.GetAccessibility(symbol.DeclaredAccessibility);
        string typeParameterList = EmitHelpers.GetTypeParameterList(symbol);
        string constraintClauses = EmitHelpers.GetTypeConstraintClauses(symbol, string.Empty);

        sb.AppendLine($"{accessibility} partial class {symbol.Name}{typeParameterList}");
        if (!string.IsNullOrEmpty(constraintClauses))
        {
            sb.Append(constraintClauses);
        }
        sb.AppendLine("{");

        string indent = "    ";
        string currentTypeDisplay = symbol.ToDisplayString(EmitHelpers.TypeDisplayFormat);

        ToResourceMethodEmitter.Emit(sb, indent, currentTypeDisplay, info);
        sb.AppendLine();
        ResourceClassEmitter.Emit(sb, indent, currentTypeDisplay, info);

        sb.AppendLine("}");

        return sb.ToString();
    }
}
